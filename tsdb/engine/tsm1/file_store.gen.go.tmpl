package tsm1

import (
	"math"
)

{{range .}}

// Count{{ .Name }}Block counts the values in the current blocks that have a timestamp
// between [min, max).
func (c *KeyCursor) Count{{ .Name }}Block(buf *[]{{ .Name }}Value, mergeValues []{{ .Name }}Value, min, max int64) (IntegerValue, error) {
	// No matching blocks to decode
	if len(c.current) == 0 && len(mergeValues) == 0 {
		return IntegerValue{min, 0}, nil
	}

	// See if any of the files have tombstones.  This is a very coarse check, we could look at the
	// tombstone for this key instead.
	var hasTombstones bool
	for _, block := range c.current {
		if block.r.HasTombstones() {
			hasTombstones = true
			break
		}
	}

	// Slowest path: If there are overlapping blocks or tombstones, we have to decode the block to
	// count them.
	if c.duplicates || hasTombstones || len(mergeValues) > 0 {
        var count int64
        minT, maxT := int64(math.MaxInt64), int64(math.MinInt64)
    LOOP_SLOW:
		vals, err := c.Read{{ .Name }}Block(buf)
		if err != nil {
			return IntegerValue{min, 0}, err
		}

		if len(vals) > 0 {
			// Merge the TSM values with any cache values that overlap
			vals = {{ .Name }}Values(vals).Merge({{ .Name }}Values(mergeValues).Include(vals[0].UnixNano(), vals[len(vals)-1].UnixNano()))
			// Drop any values outside the window
			vals = {{ .Name }}Values(vals).Include(min, max)
			// Remove the merge values so we don't double count them
			mergeValues = {{ .Name }}Values(mergeValues).Exclude(vals[0].UnixNano(), vals[len(vals)-1].UnixNano())
		} else {
			vals = {{ .Name }}Values(mergeValues).Include(min, max)
		}

		var maybeMore bool
		for _, v := range vals {
			if v.unixnano >= min && v.unixnano < max {
				if v.unixnano > maxT {
					maxT = v.unixnano
				}
				if v.unixnano <= minT {
					minT = v.unixnano
				}
				maybeMore = true
				count++
			} else if v.unixnano >= max {
				break
			}
		}

        // See if there are more values to read.
        for _, block := range c.current {
			if c.ascending {
				if maxT != math.MinInt64 {
					block.readMax = maxT
				}
			} else {
				if maxT != math.MaxInt64 {
					block.readMin = minT
				}
			}
		}

       if maybeMore {
			// See if there are more values to read.
			for _, block := range c.current {
				if block.readMin > min || block.readMax < max {
					c.NextWindow(min, max)
					goto LOOP_SLOW
				}
			}
        }
		return IntegerValue{min, count}, nil
	}

	var count int64
	for _, block := range c.current {
		if block.read() || (block.readMin <= min && block.readMax >= max) {
			continue
		}

		// Fastest path: Can we count the whole block?
		if block.entry.MinTime >= min && block.entry.MaxTime < max {
			_, cnt, err := block.r.CountBlock(&block.entry)
			if err != nil {
				return IntegerValue{min, 0}, err
			}
			block.markRead(block.entry.MinTime, block.entry.MaxTime)
			count += cnt
		} else {
			// Clamp our window to avoid counting values more than once
			minT, maxT := min, max
			if c.ascending {
				if block.readMax > min {
					minT = block.readMax
				}
			} else {
				if block.readMin < max {
					maxT = block.readMin
			    }
			}

			// Slower path: Do a partial count
			_, cnt, err := block.r.CountBlockBetween(&block.entry, minT, maxT)
			if err != nil {
				return IntegerValue{min, 0}, err
			}
			block.markRead(minT, maxT-1)
			count += cnt
		}
	}

	return IntegerValue{min, count}, nil
}

// Read{{.Name}}Block reads the next block as a set of {{.name}} values.
func (c *KeyCursor) Read{{.Name}}Block(buf *[]{{.Name}}Value) ([]{{.Name}}Value, error) {
	// No matching blocks to decode
	if len(c.current) == 0 {
		return nil, nil
	}

	// First block is the oldest block containing the points we're searching for.
	first := c.current[0]
	*buf = (*buf)[:0]
	values, err := first.r.Read{{.Name}}BlockAt(&first.entry, buf)
	if err != nil {
		return nil, err
	}

	// Remove values we already read
	values = {{.Name}}Values(values).Exclude(first.readMin, first.readMax)

	// Remove any tombstones
	tombstones := first.r.TombstoneRange(c.key)
	values = c.filter{{.Name}}Values(tombstones, values)

	// Check we have remaining values.
	if len(values) == 0 {
		return nil, nil
	}

	// Only one block with this key and time range so return it
	if len(c.current) == 1 {
		if len(values) > 0 {
			first.markRead(values[0].UnixNano(), values[len(values)-1].UnixNano())
		}
		return values, nil
	}

	// Use the current block time range as our overlapping window
	minT, maxT := first.readMin, first.readMax
	if len(values) > 0 {
		minT, maxT = values[0].UnixNano(), values[len(values)-1].UnixNano()
	}
	if c.ascending {
		// Blocks are ordered by generation, we may have values in the past in later blocks, if so,
		// expand the window to include the min time range to ensure values are returned in ascending
		// order
		for i := 1; i < len(c.current); i++ {
			cur := c.current[i]
			if cur.entry.MinTime < minT && !cur.read() {
				minT = cur.entry.MinTime
			}
		}

		// Find first block that overlaps our window
		for i := 1; i < len(c.current); i++ {
			cur := c.current[i]
			if cur.entry.OverlapsTimeRange(minT, maxT) && !cur.read() {
				// Shrink our window so it's the intersection of the first overlapping block and the
				// first block.  We do this to minimize the region that overlaps and needs to
				// be merged.
				if cur.entry.MaxTime > maxT {
					maxT = cur.entry.MaxTime
				}
				values = {{.Name}}Values(values).Include(minT, maxT)
				break
			}
		}

		// Search the remaining blocks that overlap our window and append their values so we can
		// merge them.
		for i := 1; i < len(c.current); i++ {
			cur := c.current[i]
			// Skip this block if it doesn't contain points we looking for or they have already been read
			if !cur.entry.OverlapsTimeRange(minT, maxT) || cur.read() {
				cur.markRead(minT, maxT)
				continue
			}

			tombstones := cur.r.TombstoneRange(c.key)
			var a []{{.Name}}Value
			v, err := cur.r.Read{{.Name}}BlockAt(&cur.entry, &a)
			if err != nil {
				return nil, err
			}
			// Remove any tombstoned values
			v = c.filter{{.Name}}Values(tombstones, v)

			// Remove values we already read
			v = {{.Name}}Values(v).Exclude(cur.readMin, cur.readMax)

			if len(v) > 0 {
				// Only use values in the overlapping window
				v = {{.Name}}Values(v).Include(minT, maxT)

				// Merge the remaing values with the existing
				values = {{.Name}}Values(values).Merge(v)
			}
			cur.markRead(minT, maxT)
		}

	} else {
		// Blocks are ordered by generation, we may have values in the past in later blocks, if so,
		// expand the window to include the max time range to ensure values are returned in descending
		// order
		for i := 1; i < len(c.current); i++ {
			cur := c.current[i]
			if cur.entry.MaxTime > maxT && !cur.read() {
				maxT = cur.entry.MaxTime
			}
		}

		// Find first block that overlaps our window
		for i := 1; i < len(c.current); i++ {
			cur := c.current[i]
			if cur.entry.OverlapsTimeRange(minT, maxT) && !cur.read() {
				// Shrink our window so it's the intersection of the first overlapping block and the
				// first block.  We do this to minimize the region that overlaps and needs to
				// be merged.
				if cur.entry.MinTime < minT {
					minT = cur.entry.MinTime
				}
				values = {{.Name}}Values(values).Include(minT, maxT)
				break
			}
		}

		// Search the remaining blocks that overlap our window and append their values so we can
		// merge them.
		for i := 1; i < len(c.current); i++ {
			cur := c.current[i]
			// Skip this block if it doesn't contain points we looking for or they have already been read
			if !cur.entry.OverlapsTimeRange(minT, maxT) || cur.read() {
				cur.markRead(minT, maxT)
				continue
			}

			tombstones := cur.r.TombstoneRange(c.key)

			var a []{{.Name}}Value
			v, err := cur.r.Read{{.Name}}BlockAt(&cur.entry, &a)
			if err != nil {
				return nil, err
			}
			// Remove any tombstoned values
			v = c.filter{{.Name}}Values(tombstones, v)

			// Remove values we already read
			v = {{.Name}}Values(v).Exclude(cur.readMin, cur.readMax)

			// If the block we decoded should have all of it's values included, mark it as read so we
			// don't use it again.
			if len(v) > 0 {
				v = {{.Name}}Values(v).Include(minT, maxT)
				// Merge the remaing values with the existing
				values = {{.Name}}Values(v).Merge(values)
			}
			cur.markRead(minT, maxT)
		}
	}

	first.markRead(minT, maxT)

	return values, err
}

{{ end }}
